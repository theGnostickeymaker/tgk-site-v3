// netlify/functions/stripe-webhook.js
import Stripe from "stripe";
import crypto from "crypto";
import admin from "firebase-admin";

// Initialise Firebase Admin
import admin from "firebase-admin";

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert({
      type: process.env.FIREBASE_TYPE,
      project_id: process.env.FIREBASE_PROJECT_ID,
      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
      private_key: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n"),
      client_email: process.env.FIREBASE_CLIENT_EMAIL,
      client_id: process.env.FIREBASE_CLIENT_ID,
      auth_uri: process.env.FIREBASE_AUTH_URI,
      token_uri: process.env.FIREBASE_TOKEN_URI,
      auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_CERT_URL,
      client_x509_cert_url: process.env.FIREBASE_CLIENT_CERT_URL,
      universe_domain: process.env.FIREBASE_UNIVERSE_DOMAIN
    })
  });
}

const db = admin.firestore();
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

/**
 * Handles real-time subscription events from Stripe.
 * Keeps TGK entitlements in sync when payments succeed, renew, or cancel.
 */
export async function handler(event) {
  const sig = event.headers["stripe-signature"];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  if (!webhookSecret) return json(500, { error: "Missing STRIPE_WEBHOOK_SECRET" });

  let stripeEvent;
  try {
    stripeEvent = stripe.webhooks.constructEvent(event.body, sig, webhookSecret);
  } catch (err) {
    console.error("[TGK] Stripe webhook signature failed:", err.message);
    return json(400, { error: `Webhook Error: ${err.message}` });
  }

  try {
    switch (stripeEvent.type) {

      // Subscription created or renewed
      case "customer.subscription.created":
      case "customer.subscription.updated":
      case "invoice.payment_succeeded":
        await updateEntitlements(stripeEvent.data.object.customer);
        break;

      // Subscription cancelled or payment failed
      case "customer.subscription.deleted":
      case "invoice.payment_failed":
        await clearEntitlements(stripeEvent.data.object.customer);
        break;

      default:
        console.log(`[TGK] Ignored Stripe event: ${stripeEvent.type}`);
    }

    return json(200, { received: true });

  } catch (err) {
    console.error("[TGK] Webhook processing error:", err);
    return json(500, { error: "Webhook handler error" });
  }
}

/* ======================================================
   Internal Helpers
====================================================== */

async function updateEntitlements(customerId) {
  if (!customerId) return;

  const subs = await stripe.subscriptions.list({
    customer: customerId,
    status: "active",
    limit: 1
  });

  const sub = subs.data[0];
  if (!sub) {
    console.log(`[TGK] No active subscription for ${customerId}, setting tier=free`);
    await writeToFirestore(customerId, "free", null);
    return;
  }

  const priceId = sub.items.data[0].price.id;

  const INITIATE_IDS = (process.env.PRICE_INITIATE_IDS || "").split(",").map(s => s.trim()).filter(Boolean);
  const ADEPT_IDS     = (process.env.PRICE_FULL_IDS || "").split(",").map(s => s.trim()).filter(Boolean);
  const ADEPT_LIFEIDS = (process.env.PRICE_FULL_LIFETIME_IDS || "").split(",").map(s => s.trim()).filter(Boolean);

  let tier = "free";

  if (INITIATE_IDS.includes(priceId)) tier = "initiate";
  if (ADEPT_IDS.includes(priceId) || ADEPT_LIFEIDS.includes(priceId)) tier = "adept";

  console.log(`[TGK] Determined tier for ${customerId}: ${tier}`);
  await writeToFirestore(customerId, tier, sub);
}

async function clearEntitlements(customerId) {
  console.log(`[TGK] Subscription cancelled. Setting tier=free for ${customerId}`);
  await writeToFirestore(customerId, "free", null);
}

async function writeToFirestore(customerId, tier, subscription) {
  // Match Stripe customerId to entitlement entry
  const entDocs = await db
    .collection("entitlements")
    .where("stripeCustomerId", "==", customerId)
    .get();

  if (entDocs.empty) {
    console.warn(`[TGK] No entitlements document found for Stripe customerId: ${customerId}`);
    return;
  }

  const entDoc = entDocs.docs[0];
  const uid = entDoc.id;

  const entRef = db.collection("entitlements").doc(uid);
  const subRef = db.collection("subscriptions").doc(uid);

  // Update entitlements tier
  await entRef.set(
    {
      tier,
      lastUpdated: admin.firestore.FieldValue.serverTimestamp()
    },
    { merge: true }
  );

  // Update subscription details if subscription exists
  if (subscription) {
    await subRef.set(
      {
        stripeCustomerId: customerId,
        stripeSubscriptionId: subscription.id,
        status: subscription.status,
        priceId: subscription.items.data[0].price.id,
        currentPeriodEnd: admin.firestore.Timestamp.fromMillis(
          subscription.current_period_end * 1000
        ),
        lastUpdated: admin.firestore.FieldValue.serverTimestamp()
      },
      { merge: true }
    );
  }

  console.log(`[TGK] Firestore updated: uid=${uid}, tier=${tier}`);
}

function json(statusCode, body) {
  return { statusCode, headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) };
}
